// license-header java merge-point
//
// Attention: Generated code! Do not modify by hand!
// Generated by: Enumeration.vsl in andromda-java-cartridge.
//
package finf.ucf.cu.domain;

/**
 * 
 */
public class cTime
    implements java.io.Serializable, java.lang.Comparable
{
    /**
     * The serial version UID of this class. Needed for serialization.
     */
    private static final long serialVersionUID = 6932629371818752448L;

    /**
     * 
     */
    public static final cTime PRIMERO = new cTime(1);

    /**
     * 
     */
    public static final cTime SEGUNDO = new cTime(2);

    /**
     * 
     */
    public static final cTime TERCERO = new cTime(3);

    /**
     * 
     */
    public static final cTime CUARTO = new cTime(4);

    /**
     * 
     */
    public static final cTime QUINTO = new cTime(5);

    /**
     * 
     */
    public static final cTime SEXTO = new cTime(6);

    private java.lang.Integer value;

    private cTime(java.lang.Integer value)
    {
        this.value = value;
    }

    /**
     * The default constructor allowing
     * super classes to access it.
     */
    protected cTime()
    {
    }

    /**
     * @see java.lang.Object#toString()
     */
    public String toString()
    {
        return java.lang.String.valueOf(value);
    }

    /**
     * Creates an instance of cTime from <code>value</code>.
     *
     * @param value the value to create the cTime from.
     */
    public static cTime fromInteger(java.lang.Integer value)
    {
        final cTime typeValue = (cTime)values.get(value);
        if (typeValue == null)
        {
            throw new IllegalArgumentException("invalid value '" + value + "', possible values are: " + literals);
        }
        return typeValue;
    }

    /**
     * Gets the underlying value of this type safe enumeration.
     *
     * @return the underlying value.
     */
    public java.lang.Integer getValue()
    {
        return this.value;
    }

    /**
     * @see java.lang.Comparable#compareTo(java.lang.Object)
     */
    public int compareTo(Object that)
    {
        return (this == that) ? 0 : this.getValue().compareTo(((cTime)that).getValue());
    }

    /**
     * Returns an unmodifiable list containing the literals that are known by this enumeration.
     *
     * @return A List containing the actual literals defined by this enumeration, this list
     *         can not be modified.
     */
    public static java.util.List literals()
    {
        return literals;
    }

    /**
     * Returns an unmodifiable list containing the names of the literals that are known
     * by this enumeration.
     *
     * @return A List containing the actual names of the literals defined by this
     *         enumeration, this list can not be modified.
     */
    public static java.util.List names()
    {
        return names;
    }
    
    /**
     * Returns an unmodifiable list containing the actual enumeration instance values.
     *
     * @return A List containing the actual enumeration instance values.
     */
    public static java.util.List values()
    {
        return valueList;
    }

    /**
     * @see java.lang.Object#equals(java.lang.Object)
     */
    public boolean equals(Object object)
    {
        return (this == object)
            || (object instanceof cTime && ((cTime)object).getValue().equals(
                this.getValue()));
    }

    /**
     * @see java.lang.Object#hashCode()
     */
    public int hashCode()
    {
        return this.getValue().hashCode();
    }

    /**
     * This method allows the deserialization of an instance of this enumeration type to return the actual instance
     * that will be the singleton for the JVM in which the current thread is running.
     * <p>
     * Doing this will allow users to safely use the equality operator <code>==</code> for enumerations because
     * a regular deserialized object is always a newly constructed instance and will therefore never be
     * an existing reference; it is this <code>readResolve()</code> method which will intercept the deserialization
     * process in order to return the proper singleton reference.
     * <p>
     * This method is documented here:
     * <a href="http://java.sun.com/j2se/1.3/docs/guide/serialization/spec/input.doc6.html">Java
     * Object Serialization Specification</a>
     */
    private java.lang.Object readResolve() throws java.io.ObjectStreamException
    {
        return cTime.fromInteger(this.value);
    }

    private static final java.util.Map values = new java.util.LinkedHashMap(6, 1);
    private static java.util.List literals = new java.util.ArrayList(6);
    private static java.util.List names = new java.util.ArrayList(6);
    private static java.util.List valueList = new java.util.ArrayList(6);

    /**
     * Initializes the values.
     */
    static
    {
        values.put(PRIMERO.value, PRIMERO);
        valueList.add(PRIMERO);
        literals.add(PRIMERO.value);
        names.add("PRIMERO");
        values.put(SEGUNDO.value, SEGUNDO);
        valueList.add(SEGUNDO);
        literals.add(SEGUNDO.value);
        names.add("SEGUNDO");
        values.put(TERCERO.value, TERCERO);
        valueList.add(TERCERO);
        literals.add(TERCERO.value);
        names.add("TERCERO");
        values.put(CUARTO.value, CUARTO);
        valueList.add(CUARTO);
        literals.add(CUARTO.value);
        names.add("CUARTO");
        values.put(QUINTO.value, QUINTO);
        valueList.add(QUINTO);
        literals.add(QUINTO.value);
        names.add("QUINTO");
        values.put(SEXTO.value, SEXTO);
        valueList.add(SEXTO);
        literals.add(SEXTO.value);
        names.add("SEXTO");
        valueList = java.util.Collections.unmodifiableList(valueList);
        literals = java.util.Collections.unmodifiableList(literals);
        names = java.util.Collections.unmodifiableList(names);
    }
}